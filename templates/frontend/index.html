{% extends "_bass_front.html" %}

{% block styles %}
    <!-- 复用 manage.html 的样式，去除管理相关部分 -->
    <style>
        .upload-area {
            width: 680px;
            height: 260px;
            padding: 40px;
            text-align: center;
        }
        #previewWrapper {
            position: relative;
            /* max-width: 24rem; */ /* Default width */
            overflow: hidden;
            border-radius: .75rem;
            /* transition: max-width 0.4s ease-in-out; */
        }
        #transformContainer {
            position: relative;
            transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        /* --- New Target Acquisition Animation --- */
        #target-scan-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none;
            display: none; /* Controlled by JS */
        }
        #target-box {
            position: absolute;
            border: 2px solid var(--primary-color);
            box-shadow: 0 0 15px 3px var(--glow-primary);
            transition: all 0.4s ease-in-out; /* Smooth transition for position and size */
            border-radius: .25rem;
        }
        #target-box::before,
        #target-box::after {
            content: '';
            position: absolute;
            background: var(--primary-color);
        }
        /* Vertical crosshair line */
        #target-box::before {
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            top: -15px;
            bottom: -15px;
        }
        /* Horizontal crosshair line */
        #target-box::after {
            top: 50%;
            transform: translateY(-50%);
            height: 2px;
            left: -15px;
            right: -15px;
        }

        /* --- Layout Animation: Center to Left --- */
        #previewColumn, #resultColumn {
            /* Use a nice easing function for a "silky smooth" animation */
            transition: transform 0.8s cubic-bezier(0.65, 0, 0.35, 1), opacity 0.6s cubic-bezier(0.65, 0, 0.35, 1);
        }
        .main-view.is-recognizing #resultColumn {
            opacity: 0;
            transform: translateX(50px); /* Slide out slightly to the right */
            pointer-events: none;
        }
        .main-view.is-recognizing #previewColumn {
            /* This value moves the preview to the center. It's half the width of the results column. */
            transform: translateX(340px);
        }

        /* Sticky Preview Container */
        .sticky-preview {
            position: -webkit-sticky;
            position: sticky;
            top: 5.8rem; /* Adjust to match page padding */
            align-self: start; /* Aligns to the top of the flex container */
            height: fit-content; /* Prevents the column from stretching */
        }
        /* On smaller screens, the layout is stacked, so we don't need the horizontal shift */
        @media (max-width: 991.98px) {
            .main-view.is-recognizing #previewColumn {
                transform: translateX(0);
            }
        }
        /* 手机端适配 */
        @media (max-width: 991.98px) { /* Corresponds to Bootstrap's 'lg' breakpoint */
          .sticky-preview {
              position: static;
          }
        }
        /*
        #previewWrapper.wide {
            max-width: 36rem; 
        }
        */
        #previewImg {
            display: block;
            width: auto;
            height: auto;
            border-radius: .75rem;
            box-shadow: 0 4px 8px var(--c-shadow), 0 10px 20px var(--c-shadow-lg);
            border: 1px solid color-mix(in srgb, var(--c-border), transparent 50%);
            transition: width 0.4s ease, height 0.4s ease;
        }
        #previewImg.aspect-normal {
            width: 24rem;
        }
        #previewImg.aspect-wide {
            width: 36rem;
        }
        #previewImg.aspect-tall {
            height: 70vh;
        }
        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            border-radius: .75rem;
            transition: all 0.2s ease;
        }
        #previewWrapper .preview-shadow-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            border-radius: .75rem;
            pointer-events: none;
            z-index: 4;
            display: none; /* Initially hidden */
        }
        #previewWrapper .crosshair-line {
            position: absolute;
            background-color: #ff3a3a; /* Bright red */
            box-shadow: 0 0 10px 1px #ff3a3a;
            pointer-events: none;
            z-index: 5;
            display: none; /* Initially hidden */
            border-radius: 1px;
        }
        /* --- New Highlight Effect Styles --- */
        #highlight-box {
            position: absolute;
            display: none;
            pointer-events: none;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.55);
            z-index: 5;
            border: 2px solid rgba(0, 255, 255, 0.8);
            transition: all 0.4s ease-in-out; /* Smooth transition for position, size, and transforms */
        }

        #highlight-box span {
            display: block;
            width: 100%;
            height: 100%;
        }

        #highlight-box::before, /* Top */
        #highlight-box::after,  /* Bottom */
        #highlight-box span::before, /* Left */
        #highlight-box span::after {  /* Right */
            content: '';
            position: absolute;
            background: #00ffff;
            box-shadow: 0 0 12px 2px #00ffff;
            z-index: 6;
        }

        /* Vertical lines */
        #highlight-box::before,
        #highlight-box::after {
            left: 50%;
            width: 2px;
            transform: translateX(-50%);
        }

        /* Horizontal lines */
        #highlight-box span::before,
        #highlight-box span::after {
            top: 50%;
            height: 2px;
            transform: translateY(-50%);
        }

        /* Position them outside the box */
        #highlight-box::before { /* Top */
            bottom: 100%;
            height: 9999px;
        }
        #highlight-box::after { /* Bottom */
            top: 100%;
            height: 9999px;
        }
        #highlight-box span::before { /* Left */
            right: 100%;
            width: 9999px;
        }
        #highlight-box span::after { /* Right */
            left: 100%;
            width: 9999px;
        }

        .result-column-container {
            width: 680px;
            max-width: 1000px;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity .5s ease-out, transform .5s ease-out;
        }
        .result-column-container.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .group-header {
            font-weight: 500;
            color: var(--c-text);
            margin: 0 0 1rem 0;
            padding-bottom: .75rem;
            border-bottom: 1px solid var(--c-border);
            opacity: 0;
            animation: fadeInUp .5s ease-out forwards;
        }
        .face-card {
            background: transparent;
            transition: transform 0.25s ease, box-shadow 0.25s ease;
            border-radius: .75rem;
            border: 0.1px solid color-mix(in srgb, var(--c-text), transparent 60%);
            box-shadow: none;
            opacity: 0;
            transform: translateY(15px);
            animation: fadeInUp .5s ease-out forwards;
            height: 100%;
            min-width: 300px;
            max-width: 600px;
            width: 100%;
        }
        .face-card:hover {
            transform: translateY(-5px) scale(1.02);
            box-shadow: 0 8px 16px var(--c-shadow);
            border-color: var(--accent-color);
            background: var(--c-card);
        }
        .face-card-img-container {
            flex-shrink: 0;
            box-shadow: 0 4px 8px var(--c-shadow-lg);
            border-radius: .5rem;
        }
        .face-card .progress {
            background-color: color-mix(in srgb, var(--accent-color), transparent 85%);
            height: 6px;
            border-radius: 3px;
        }
        .face-card .progress-bar {
            border-radius: 3px;
        }
        .main-view, #uploadWrapper {
            transition: opacity .4s ease-out, transform .4s ease-out;
        }
        .main-view {
            flex-grow: 1; /* Ensure it takes up available space for sticky to work */
        }
        .hidden {
            display: none !important;
        }
        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        @keyframes fadeIn {
            to { opacity: 1; }
        }
    </style>
{% endblock %}

{% block content %}
    <div id="uploadWrapper" class="d-flex flex-column align-items-center justify-content-center flex-grow-1">
        <form id="uploadForm" class="upload-area d-flex flex-column align-items-center justify-content-center gap-3 frosted-glass-card">
            <input type="file" id="imageFile" accept="image/*" class="d-none" required />
            <svg xmlns="http://www.w3.org/2000/svg" width="56" height="56" fill="currentColor" class="bi bi-cloud-arrow-up" viewBox="0 0 16 16">
                <path fill-rule="evenodd" d="M7.646 5.146a.5.5 0 0 1 .708 0l2 2a.5.5 0 0 1-.708.708L8.5 6.707V10.5a.5.5 0 0 1-1 0V6.707L6.354 7.854a.5.5 0 1 1-.708-.708l2-2z"/>
                <path fill-rule="evenodd" d="M4.406 3.342A5.53 5.53 0 0 1 8 0c2.69 0 4.923 2 5.166 4.579C14.758 4.804 16 6.137 16 7.773 16 9.569 14.502 11 12.687 11H10.5a.5.5 0 0 1 0-1h2.188C13.938 10 15 8.981 15 7.773c0-1.216-1.02-2.228-2.313-2.228h-.5v-.5C12.188 2.825 10.328 1 8 1a4.53 4.53 0 0 0-4.242 3.22c-.226.66-.468 1.359-.732 2.028C2.7 6.45 2.5 7.009 2.5 7.5c0 1.065.865 2 2.22 2h1.03a.5.5 0 0 1 0 1H4.72C2.01 10.5 0 8.544 0 6.314 0 4.894 1.053 3.65 2.458 3.235c.29-.08.578-.17.857-.268z"/>
            </svg>
            <p class="text-muted m-0">拖拽图片到此或点击选择</p>
        </form>
    </div>
    <div class="main-view hidden" id="mainView">
        <div id="mainViewContent" class="p-4">
            <div class="row flex-lg-nowrap justify-content-center align-items-start w-100">
                <div id="previewColumn" class="col-lg-auto mb-4 mb-lg-0 sticky-preview">
                    <div id="previewWrapper">
                        <div id="transformContainer">
                            <img id="previewImg" src="" alt="preview" />
                            <canvas id="overlayCanvas"></canvas>
                            <div id="highlight-box"><span></span></div>
                        </div>
                        <div id="target-scan-overlay">
                            <div id="target-box"></div>
                        </div>
                    </div>
                </div>
                <div id="resultColumn" class="col-lg-auto result-column-container">
                    <div id="resultContainer"></div>
                </div>
            </div>
        </div>
    </div>
{% endblock %}

{% block scripts %}
    <script id="app-config"
        data-animation-speed-random="{{ config.animation_speed_random }}"
        data-animation-speed-target="{{ config.animation_speed_target }}"
        data-enable-upload-compression="{{ config.get('enable_upload_compression', True) | tojson }}">
    </script>
    <script>
    // 复用 manage.html 的识别主流程，去除管理相关部分
    $(function() {
        const configElement = document.getElementById('app-config');
        const animationSpeedRandom = parseInt(configElement.dataset.animationSpeedRandom, 10);
        const animationSpeedTarget = parseInt(configElement.dataset.animationSpeedTarget, 10);
        const enableUploadCompression = configElement.dataset.enableUploadCompression === 'true';

        const uploadWrapper = document.getElementById("uploadWrapper");
        const uploadForm = document.getElementById("uploadForm");
        const imageFile = document.getElementById("imageFile");
        const previewImg = document.getElementById("previewImg");
        const previewWrapper = document.getElementById('previewWrapper');
        const transformContainer = document.getElementById('transformContainer');
        const overlayCanvas = document.getElementById("overlayCanvas");
        const targetScanOverlay = document.getElementById("target-scan-overlay");
        const mainView = document.getElementById("mainView");
        const resultContainer = document.getElementById("resultContainer");
        const resultColumn = document.getElementById("resultColumn");
        let currentFaces = [];
        let originalImageFile = null;
        let compressedFileToUpload = null;
        let scanAnimationInterval = null;
        let isScanning = false;
        let detectedFaceBoxes = [];

        /**
         * Compresses an image file before uploading.
         * @param {File} file The original image file.
         * @returns {Promise<Blob>} A promise that resolves with the compressed image as a Blob.
         */
        function compressImage(file) {
            return new Promise((resolve, reject) => {
                const MAX_DIMENSION = 1920; // Max width or height
                const QUALITY = 0.85;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        let width = img.width;
                        let height = img.height;

                        if (width > height) {
                            if (width > MAX_DIMENSION) {
                                height *= MAX_DIMENSION / width;
                                width = MAX_DIMENSION;
                            }
                        } else {
                            if (height > MAX_DIMENSION) {
                                width *= MAX_DIMENSION / height;
                                height = MAX_DIMENSION;
                            }
                        }

                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);

                        canvas.toBlob(
                            (blob) => {
                                if (blob) {
                                    console.log(`Image compressed from ${Math.round(file.size / 1024)} KB to ${Math.round(blob.size / 1024)} KB.`);
                                    resolve(blob);
                                } else {
                                    reject(new Error('Canvas to Blob conversion failed.'));
                                }
                            },
                            'image/jpeg',
                            QUALITY
                        );
                    };
                    img.onerror = (err) => reject(err);
                    img.src = event.target.result;
                };
                reader.onerror = (err) => reject(err);
                reader.readAsDataURL(file);
            });
        }
        
        function setupUploadListeners(element, isClickable = true) {
            if (isClickable) {
                element.addEventListener("click", () => imageFile.click());
            }
            ["dragenter", "dragover"].forEach(evt => {
                element.addEventListener(evt, e => {
                    e.preventDefault();
                    e.stopPropagation();
                    const targetElement = element.id === 'previewWrapper' ? uploadForm : element;
                    targetElement.classList.add("dragover");
                    if (element.id === 'previewWrapper') {
                        element.classList.add('active-dropzone');
                    }
                });
            });
            ["dragleave", "drop"].forEach(evt => {
                element.addEventListener(evt, e => {
                    e.preventDefault();
                    e.stopPropagation();
                    const targetElement = element.id === 'previewWrapper' ? uploadForm : element;
                    targetElement.classList.remove("dragover");
                    if (element.id === 'previewWrapper') {
                        element.classList.remove('active-dropzone');
                    }
                });
            });
            element.addEventListener("drop", e => {
                imageFile.files = e.dataTransfer.files;
                showPreviewAndSubmit();
            });
        }
        setupUploadListeners(uploadForm);
        setupUploadListeners(previewWrapper, false);
        previewImg.addEventListener("click", () => imageFile.click());
        imageFile.addEventListener("change", showPreviewAndSubmit);
        document.addEventListener('paste', function (event) {
            if (event.clipboardData && event.clipboardData.items) {
                for (let i = 0; i < event.clipboardData.items.length; i++) {
                    const item = event.clipboardData.items[i];
                    if (item.kind === 'file' && item.type.startsWith('image/')) {
                        const file = item.getAsFile();
                        if (file) {
                            const dataTransfer = new DataTransfer();
                            dataTransfer.items.add(file);
                            imageFile.files = dataTransfer.files;
                            showPreviewAndSubmit();
                            event.preventDefault();
                            break;
                        }
                    }
                }
            }
        });
        async function showPreviewAndSubmit() {
            if (!imageFile.files.length) return;

            // Reset any active hover/zoom effects from the previous result
            transformContainer.style.transform = 'scale(1) translate(0px, 0px)';
            const highlightBox = document.getElementById('highlight-box');
            if (highlightBox) {
                highlightBox.style.display = 'none';
            }

            currentFaces = [];
            originalImageFile = imageFile.files[0];
            compressedFileToUpload = null; // Reset compressed file
            const ctx = overlayCanvas.getContext("2d");
            ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            resultContainer.innerHTML = "";
            resultColumn.classList.remove("visible");
            mainView.classList.add('is-recognizing');
            uploadWrapper.classList.add('hidden');
            
            if (enableUploadCompression) {
                try {
                    compressedFileToUpload = await compressImage(originalImageFile);
                } catch (err) {
                    console.error('Compression error:', err);
                    compressedFileToUpload = originalImageFile;
                }
            } else {
                compressedFileToUpload = originalImageFile;
            }

            const fileURL = URL.createObjectURL(compressedFileToUpload);
            previewImg.src = fileURL;
            mainView.classList.remove('hidden');
            previewImg.onload = () => {
                // Adjust width for wide images
                const ratio = previewImg.naturalWidth / previewImg.naturalHeight;
                previewImg.className = ''; // Reset classes first
                if (ratio > 1.2) {
                    previewImg.classList.add('aspect-wide');
                } else if (ratio < 0.85) {
                    previewImg.classList.add('aspect-tall');
                } else {
                    previewImg.classList.add('aspect-normal');
                }
                resizeCanvas();
                showToast('图片加载成功，即将开始识别...', 'info', 2000);
                handleSubmit();
            };
        }
        function resizeCanvas() {
            overlayCanvas.width = previewImg.clientWidth;
            overlayCanvas.height = previewImg.clientHeight;
            drawBoxes(currentFaces);
        }
        window.addEventListener("resize", resizeCanvas);
        async function handleSubmit() {
            resultContainer.innerHTML = "";
            resultColumn.classList.remove("visible");
            isScanning = true;
            detectedFaceBoxes = []; // 重置检测到的人脸框
            startScanAnimation(); // 先开始随机扫描
            const startTime = performance.now();
            
            let fileToUpload = originalImageFile;
            if (enableUploadCompression) {
                try {
                    fileToUpload = await compressImage(originalImageFile);
                } catch (err) {
                    console.error('Compression error:', err);
                    fileToUpload = originalImageFile; // Fallback
                }
            }

            const formData = new FormData();
            formData.append("file", fileToUpload, originalImageFile.name);
            formData.append("stream_progress", "1"); // 请求流式响应

            try {
                const response = await fetch("/api/recognize", {
                    method: "POST",
                    body: formData,
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `请求失败，状态码: ${response.status}`);
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = "";

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    
                    // Process all complete messages in the buffer
                    while (buffer.includes("\n\n")) {
                        const messageEndIndex = buffer.indexOf("\n\n");
                        const message = buffer.substring(0, messageEndIndex);
                        buffer = buffer.substring(messageEndIndex + 2);

                        let eventType = 'message';
                        let data = '';
                        
                        message.split('\n').forEach(line => {
                            if (line.startsWith('event:')) {
                                eventType = line.substring(7).trim();
                            } else if (line.startsWith('data:')) {
                                data = line.substring(5).trim();
                            }
                        });

                        if (data) {
                            const jsonData = JSON.parse(data);
                            if (eventType === 'detected') {
                                handleDetectedEvent(jsonData);
                            } else if (eventType === 'completed') {
                const duration = ((performance.now() - startTime) / 1000).toFixed(2);
                                await handleCompletedEvent(jsonData, duration);
                            } else if (eventType === 'error') {
                                handleErrorEvent(jsonData);
                            }
                        }
                    }
                }

            } catch (err) {
                console.error(err);
                resultColumn.classList.add("visible");
                resultContainer.innerHTML = `<p class='text-danger text-center mt-4'>${err.message}</p>`;
                showToast(err.message, 'danger');
                stopScanAnimation();
                isScanning = false;
                mainView.classList.remove('is-recognizing');
            }
        }

        function handleDetectedEvent(data) {
            console.log("Detected event:", data);
            detectedFaceBoxes = data.boxes || [];
            if (detectedFaceBoxes.length > 0) {
                // 收到人脸位置后，切换到基于人脸的扫描动画
                startScanAnimationOnFaces();
            }
        }

        async function handleCompletedEvent(data, duration) {
            console.log("Completed event:", data);
            currentFaces = data.faces || [];
            await renderResult(currentFaces);
            resultColumn.classList.add("visible");
            showToast(`识别完成！耗时 ${duration} 秒，共找到 ${currentFaces.length} 张人脸。`, 'success');
            stopScanAnimation();
            isScanning = false;
            mainView.classList.remove('is-recognizing');
        }

        function handleErrorEvent(data) {
             console.error("Error event:", data);
            const errorMessage = data.error || "发生未知错误";
            resultColumn.classList.add("visible");
            resultContainer.innerHTML = `<p class='text-danger text-center mt-4'>${errorMessage}</p>`;
            showToast(errorMessage, 'danger');
            stopScanAnimation();
            isScanning = false;
            mainView.classList.remove('is-recognizing');
        }

        function startScanAnimation() {
            if (scanAnimationInterval) clearInterval(scanAnimationInterval);
            const highlightBox = document.getElementById('highlight-box');
            if (!highlightBox) return;

            highlightBox.style.display = 'block';

            const moveAndResizeBox = () => {
                const containerW = previewImg.clientWidth;
                const containerH = previewImg.clientHeight;

                // Set size constraints for the box
                const minSize = Math.min(containerW, containerH) * 0.15;
                const maxSize = Math.min(containerW, containerH) * 0.35;
                
                const newSize = Math.random() * (maxSize - minSize) + minSize;
                
                const newX = Math.random() * (containerW - newSize);
                const newY = Math.random() * (containerH - newSize);

                highlightBox.style.width = `${newSize}px`;
                highlightBox.style.height = `${newSize}px`;
                highlightBox.style.left = `${newX}px`;
                highlightBox.style.top = `${newY}px`;
            };
            
            moveAndResizeBox(); // Initial position
            scanAnimationInterval = setInterval(moveAndResizeBox, animationSpeedRandom);
        }

        function startScanAnimationOnFaces() {
            if (scanAnimationInterval) clearInterval(scanAnimationInterval);
            if (detectedFaceBoxes.length === 0) {
                startScanAnimation(); // Fallback to random if no faces
                return;
            }

            const highlightBox = document.getElementById('highlight-box');
            if (!highlightBox) return;

            highlightBox.style.display = 'block';
            let currentFaceIndex = 0;

            const moveToFace = () => {
                const box = detectedFaceBoxes[currentFaceIndex];
                const scaleX = previewImg.clientWidth / previewImg.naturalWidth;
                const scaleY = previewImg.clientHeight / previewImg.naturalHeight;
                const [x1, y1, x2, y2] = box;
                
                const boxWidth = (x2 - x1) * scaleX;
                const boxHeight = (y2 - y1) * scaleY;
                const boxX = x1 * scaleX;
                const boxY = y1 * scaleY;

                highlightBox.style.width = `${boxWidth}px`;
                highlightBox.style.height = `${boxHeight}px`;
                highlightBox.style.left = `${boxX}px`;
                highlightBox.style.top = `${boxY}px`;

                currentFaceIndex = (currentFaceIndex + 1) % detectedFaceBoxes.length;
            };

            moveToFace(); // Initial position
            scanAnimationInterval = setInterval(moveToFace, animationSpeedTarget); // Slower interval for deliberate scanning
        }

        function stopScanAnimation() {
            if (scanAnimationInterval) clearInterval(scanAnimationInterval);
            scanAnimationInterval = null;
            const highlightBox = document.getElementById('highlight-box');
            if (highlightBox) {
                highlightBox.style.display = 'none';
            }
        }
        function createScanGrid() {
            // This function is no longer needed for the holographic effect,
            // but keeping it as it might be used elsewhere or for future features.
            // The target-scan-overlay handles its own grid points.
        }
        function drawBoxes(faces, highlightedIndex = -1) {
            const ctx = overlayCanvas.getContext("2d");
            ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            if (!faces.length) return;
            const scaleX = previewImg.clientWidth / previewImg.naturalWidth;
            const scaleY = previewImg.clientHeight / previewImg.naturalHeight;
            faces.forEach((f, index) => {
                const [x1, y1, x2, y2] = f.bounding_box;
                const isHighlighted = index === highlightedIndex;
                ctx.strokeStyle = isHighlighted ? 'var(--glow-accent)' : 'var(--primary-color)';
                ctx.lineWidth = isHighlighted ? 3 : 2;
                if (isHighlighted) {
                    ctx.shadowColor = 'var(--glow-accent)';
                    ctx.shadowBlur = 10;
                }
                ctx.strokeRect(x1 * scaleX, y1 * scaleY, (x2 - x1) * scaleX, (y2 - y1) * scaleY);
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
            });
        }
        async function renderResult(faces) {
            resultContainer.innerHTML = "";
            drawBoxes(faces);
            if (!faces.length) {
                resultContainer.innerHTML = "<p class='text-muted text-center mt-4'>未检测到人脸</p>";
                return;
            }

            // IMPORTANT: Create an Image object from the ORIGINAL file for high-quality cropping
            const imageForCropping = new Image();
            imageForCropping.src = URL.createObjectURL(originalImageFile);
            await new Promise(resolve => imageForCropping.onload = resolve);

            // Calculate scaling factors between original and displayed (compressed) image
            const originalWidth = imageForCropping.naturalWidth;
            const originalHeight = imageForCropping.naturalHeight;
            const displayedWidth = previewImg.naturalWidth;
            const displayedHeight = previewImg.naturalHeight;
            
            const scaleX = originalWidth / displayedWidth;
            const scaleY = originalHeight / displayedHeight;

            const groups = {};
            faces.forEach(f => {
                const key = f.identity === "未知角色" ? "未知角色" : f.anime || "未知作品";
                if (!groups[key]) {
                    groups[key] = { faces: [], maxScore: 0 };
                }
                groups[key].faces.push(f);
                if (f.score > groups[key].maxScore) groups[key].maxScore = f.score;
            });
            const groupNames = Object.keys(groups).sort((a, b) => {
                if (a === "未知角色") return 1;
                if (b === "未知角色") return -1;
                return groups[b].faces.length - groups[a].faces.length;
            });
            let animationDelay = 0;
            groupNames.forEach(groupName => {
                const groupWrapper = document.createElement('div');
                groupWrapper.className = 'result-group frosted-glass-card p-3 mb-3';
                const header = document.createElement('h5');
                header.className = 'group-header';
                header.textContent = groupName;
                header.style.animationDelay = `${animationDelay}ms`;
                groupWrapper.appendChild(header);
                animationDelay += 100;
                const cardsContainer = document.createElement('div');
                cardsContainer.className = 'row g-3';
                const facesArr = groups[groupName].faces.sort((a, b) => b.score - a.score);
                facesArr.forEach(f => {
                    const originalIndex = faces.indexOf(f);
                    const col = document.createElement("div");
                    col.className = "col-xl-6";
                    const scoreNum = parseFloat(f.score) || 0;
                    const percent = Math.round(scoreNum * 100);
                    const colorClass = percent >= 80 ? 'bg-success' : percent >= 60 ? 'bg-info' : 'bg-warning';
                    
                    let correctionTagHTML = '';
                    if (f.is_corrected) {
                        correctionTagHTML = `<div class='text-danger small mt-1'>*已由全局分析修正</div>`;
                    }

                    let orientationTagHTML = '';
                    if (f.first_class === 0) {
                        orientationTagHTML = `<span class='text-success fw-bold me-1'>(正)</span>`;
                    } else if (f.first_class === 1) {
                        orientationTagHTML = `<span class='text-info fw-bold me-1'>(背)</span>`;
                    }

                    // Placeholder for the image
                    const imageId = `face-img-${originalIndex}`;

                    const cardHTML = `
                        <div class="face-card p-3" data-face-index="${originalIndex}" style="animation-delay: ${animationDelay}ms;">
                            <div class="d-flex align-items-center">
                                <div class="face-card-img-container me-3">
                                    <img id="${imageId}" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" width="64" height="64" class="rounded-2" style="object-fit: cover;">
                                </div>
                                <div class="flex-grow-1" style="min-width: 0;">
                                    <div class="d-flex align-items-baseline w-100">
                                        ${orientationTagHTML}
                                        <h6 class='fw-bold mb-0 text-truncate' title="${f.name}">${f.name}</h6>
                                    </div>
                                    ${correctionTagHTML}
                                    <p class='small text-muted mb-0 mt-1 text-truncate' title="${f.anime}">${f.anime}</p>
                                </div>
                            </div>
                            <div class="mt-3">
                                <div class='small text-muted d-flex justify-content-between mb-1'>
                                    <span>置信度</span>
                                    <span>${percent}%</span>
                                </div>
                                <div class="progress">
                                    <div class="progress-bar ${colorClass}" role="progressbar" style="width:${percent}%" aria-valuenow="${percent}"></div>
                                </div>
                            </div>
                        </div>
                    `;
                    col.innerHTML = cardHTML;
                    cardsContainer.appendChild(col);
                     // --- SCALED CROPPING ---
                     // The coordinates from server are for the compressed image.
                     // We must scale them to crop from the high-resolution original `imageForCropping`.
                    const scaledBoundingBox = f.bounding_box.map((v, i) => i % 2 === 0 ? v * scaleX : v * scaleY);
                    
                    // Crop and set the image for display
                    cropFaceFromImage(imageForCropping, scaledBoundingBox, 112, 112).then(dataUrl => {
                        const imgElement = document.getElementById(imageId);
                        if (imgElement) {
                            imgElement.src = dataUrl;
                        }
                    });

                    animationDelay += 80;
                });
                groupWrapper.appendChild(cardsContainer);
                resultContainer.appendChild(groupWrapper);
            });
            document.querySelectorAll('.face-card').forEach(card => {
                const index = parseInt(card.dataset.faceIndex, 10);
                const faceData = faces[index];
                
                const elementsToHover = card.querySelectorAll('.face-card-img-container, h6.fw-bold');

                const showHighlight = () => {
                    if (isScanning) return; // Don't show hover effect during scan animation
                    const highlightBox = document.getElementById('highlight-box');
                    const overlayCanvas = document.getElementById('overlayCanvas');
                    if (highlightBox && faceData) {
                        const scaleX = previewImg.clientWidth / previewImg.naturalWidth;
                        const scaleY = previewImg.clientHeight / previewImg.naturalHeight;
                        const [x1, y1, x2, y2] = faceData.bounding_box;

                        const top = y1 * scaleY;
                        const left = x1 * scaleX;
                        const width = (x2 - x1) * scaleX;
                        const height = (y2 - y1) * scaleY;

                        highlightBox.style.cssText = `
                            display: block;
                            top: ${top}px;
                            left: ${left}px;
                            width: ${width}px;
                            height: ${height}px;
                        `;
                    }
                    // Keep original box drawing logic, maybe for a thicker border on selection
                    drawBoxes(faces, index);

                    // --- Zoom In Logic ---
                    const zoomScale = 1.7;
                    const transformOrigin = '0 0';

                    const scaleX = previewImg.clientWidth / previewImg.naturalWidth;
                    const scaleY = previewImg.clientHeight / previewImg.naturalHeight;

                    const boxCenterX = ((faceData.bounding_box[0] + faceData.bounding_box[2]) / 2) * scaleX;
                    const boxCenterY = ((faceData.bounding_box[1] + faceData.bounding_box[3]) / 2) * scaleY;
                    
                    const imgCenterX = previewImg.clientWidth / 2;
                    const imgCenterY = previewImg.clientHeight / 2;

                    const translateX = imgCenterX - (boxCenterX * zoomScale);
                    const translateY = imgCenterY - (boxCenterY * zoomScale);

                    const transformString = `scale(${zoomScale}) translate(${translateX / zoomScale}px, ${translateY / zoomScale}px)`;

                    transformContainer.style.transformOrigin = transformOrigin;
                    transformContainer.style.transform = transformString;
                };

                const hideHighlight = () => {
                    if (isScanning) return; // Don't hide during scan animation
                    const highlightBox = document.getElementById('highlight-box');
                    if (highlightBox) {
                        highlightBox.style.display = 'none';
                    }
                    drawBoxes(faces, -1);

                    // --- Zoom Out Logic ---
                    transformContainer.style.transform = 'scale(1) translate(0px, 0px)';
                };

                elementsToHover.forEach(el => {
                    el.addEventListener('mouseenter', showHighlight);
                    el.addEventListener('mouseleave', hideHighlight);
                });

            });
        }
        
        async function cropFaceFromImage(image, box, targetWidth, targetHeight) {
            const [x1, y1, x2, y2] = box;
            const cropWidth = x2 - x1;
            const cropHeight = y2 - y1;

            const canvas = document.createElement('canvas');
            canvas.width = targetWidth;
            canvas.height = targetHeight;
            const ctx = canvas.getContext('2d');

            // --- 新增：绘制带黑边的 padding ---
            // 计算缩放比例，使图像适应目标尺寸，而不是拉伸
            const ratio = Math.min(targetWidth / cropWidth, targetHeight / cropHeight);
            const drawWidth = cropWidth * ratio;
            const drawHeight = cropHeight * ratio;
            const offsetX = (targetWidth - drawWidth) / 2;
            const offsetY = (targetHeight - drawHeight) / 2;

            // 填充黑色背景
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, targetWidth, targetHeight);

            // 将裁剪的图像绘制到 canvas 的中心
            ctx.drawImage(
                image,
                x1, y1, cropWidth, cropHeight, // source rectangle
                offsetX, offsetY, drawWidth, drawHeight // destination rectangle
            );
            return canvas.toDataURL('image/png');
        }

    });
    </script>
{% endblock %}